# ebclfsa-demo

This directory contains a demo, that is automatically installed into the ebclfsa qemu demo image.
It consists of three applications, two are started on the high integrity vm (hi_main and hi_forward) and the third can be started in the low integrity vm.
The three applications communicate over shared memory.

## How to build
The high and low integrity applications use different toolchains.
For the low integrity application the same toolchain is used as is used for normal ebcl applications.
The high integrity application uses musl and gcc and has to be compiled statically.

The required toolchains are selected using cmake presets.
To compile the application the vscode cmake integration can be used or just `cmake --preset li-app ...` for the low integrity application or `cmake --preset hi-app ...` for the high integrity application.
The vscode integration also allows debugging of the low integrity application in gdb.
The high integrity application cannot be debugged right now.

NOTE: musl and gcc are just an intermediate solution used here for demonstration purposes and will change in the future.

## Expected output
When li_demo is executed, while the high integrity applications are running, the following output is expected:


    li_demo: INFO: Hello from ebclfsa low integrity demo application
    li_demo: DEBUG: Base addr of hv_proxycomshm is: 0x4a1fa000 - 0x4a3f9fff
    li_demo: DEBUG: Opened /dev/mem: 3
    li_demo: DEBUG: Mapped shared memory: 0x0000ffff93180000
    li_demo: DEBUG: Base addr of hv_fbshm is: 0x471fa000 - 0x4a1f9fff
    li_demo: DEBUG: Opened /dev/mem: 3
    li_demo: DEBUG: Mapped shared memory: 0x0000ffff90180000
    li_demo: INFO: Waiting for high integrity apps to start...
    li_demo: INFO: high integrity app is available, starting communication
    li_demo: INFO: Sending 'Hello hi_app 0'
    vm-hi | hi_main: DEBUG: Received 'Hello hi_app 0' from li
    vm-hi | hi_forward: DEBUG: Received 'You said 'Hello hi_app 0', I say 'hello li_app 1'' from hi_demo
    li_demo: INFO: Got response: YOU SAID 'HELLO HI_APP 0', I SAY 'HELLO LI_APP 1'
    li_demo: INFO: Sending 'Hello hi_app 1'
    vm-hi | hi_main: DEBUG: Received 'Hello hi_app 1' from li
    vm-hi | hi_forward: DEBUG: Received 'You said 'Hello hi_app 1', I say 'hello li_app 2'' from hi_demo
    li_demo: INFO: Got response: YOU SAID 'HELLO HI_APP 1', I SAY 'HELLO LI_APP 2'
    [...]

The first few messages show the retrieval of the shared memory addresses from the device tree and the mapping into the process memory.
Then the application looks for the shared memory partitions used by the two high integrity applications.
After that the first message is send to the hi_main application.
It is received, modified and forwarded to hi_forward, which in turn sends it back to li_demo.
The messages starting with `vm-hi | hi_` are directly generated by the high integrity applications.

This continues for 10 roundtrips and then li_demo terminates.


## Communication
The demo uses two shared memory segments:
 * proxycom: This is used to communicate from a low integrity application to a high integrity application.
   In the demo it is partitioned into multiple chunks, one for each running high integrity application.
   The high integrity applications register themselves in this memory with a UUID, that is used to find the correct partition by the low integrity application.
 * hicom: This is used to communicate between high integrity applications.
   It cannot be accessed by low integrity applications

Messages are passed between applications using the shared memory and a ringbuffer.

The following sequence of messages is sent:

1. li_demo sends a message over the proxycom shared memory to hi_main.
2. The message is received by hi_main, manipulated and send to hi_forward over the hicom shared memory.
3. hi_forward then sends the message back to hi_demo using proxycom.

## Watchdog
There is a watchdog process running as part of the hypervisor.
The watchdog has to be triggered regularly by the hi integrity application.
Since there is only one watchdog available, aggregation of watchdog signals is the responsibility of the (first) high integrity application.
Therefor the second high integrity application (hi_forward) signals a watchdog to the first high integrity application (hi_main) using the hicom shared memory.
Then hi_main can trigger the watchdog.

The watchdog leaves the system some time to completely boot up.
For qemu this timeout is rather long (~50s), because qemu performance can vary a lot.
A message is printed to the console, when this timeout is expired and the watchdog is active:

    HealthSigHdl: msg received mr[0]=3855 eol


From now on the watchdog must be triggered periodically, if it is not triggered any more the following message is printed. This can be triggered by running `li_demo -s`, which tells li_main to stop triggering the watchdog.

    SafeHM: (ERROR) Heartbeat not received from Client with id = 12
    SafeHM: (ERROR) safe_state (exit_code=-1)

The watchdog cannot be restarted and the system has to be rebooted.

NOTE: For qemu this has no further effect.


## Not allowed syscalls
Not all syscalls are allowed in ebclfsa high integrity applications.
In the qemu setup calling a prohibited syscall does not have any effect apart from a message on the console.
On a real safety system calling a prohibited syscall will trigger a transition to the safe more.

To test executing a not allowed syscall `li_demo -p` can be executed, which calls `ioctl(0, 0)` and yields the following message:

    SDK:handler_do_el0_svc_pre: syscall __NR_ioctl (29) is not allowed

NOTE: The current state of the syscalls whitelist does not reflect the final list of allowed syscalls!
